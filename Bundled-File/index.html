<!DOCTYPE html>
<html>
  <head>
    <title>WebCraft</title>
    <link rel="stylesheet" href="styles.css" />
    <!-- Load Three.js from CDN first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
  <body>
      <div id="container"></div>
      <!-- Load your script AFTER Three.js is loaded -->
      <script src="script.js"></script>
  </body>
</html>
<style>
    body {
    margin: 0;
    overflow: hidden; /* Hide scroll bars */
}
canvas {
    display: block; /* Removes default margin/padding around canvas */
}
</style>
<script>
    // script.js

// === 1. Setup the Scene, Camera, and Renderer ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });

renderer.setSize(window.innerWidth, window.innerHeight);
// Append the renderer's DOM element (the <canvas>) to the body
document.body.appendChild(renderer.domElement);

// Position the camera
camera.position.z = 5;
camera.position.y = 2;

// === Camera Animation Variables ===
// Tracks the angle of the camera as it orbits the tree
let cameraAngle = 0;
// Radius of the camera's orbit
const orbitRadius = 5;

// Colors
// Define color materials as variables
const White = new THREE.MeshBasicMaterial({ color: '#FFFFFF' });
const Gray = new THREE.MeshBasicMaterial({ color: '#737272' });
const Black = new THREE.MeshBasicMaterial({ color: '#000000' });
const Cyan = new THREE.MeshBasicMaterial({ color: '#00FFD7' });
const DarkBlue = new THREE.MeshBasicMaterial({ color: '#051F85' });
const Brown = new THREE.MeshBasicMaterial({ color: '#6B3E04' });
const Green = new THREE.MeshBasicMaterial({ color: '#047D0E' });

// Colors array (currently unused in the code logic, kept for reference)
const Colors = [
    White,
    Gray,
    Black,
    Cyan,
    DarkBlue,
    Brown,
    Green
];

// Define the geometry once
const geometry = new THREE.BoxGeometry(1, 1, 1);

// === Global Group Variables ===
// We use single global variables to hold our groups of objects
let treeGroup;
let chunkGroup;


function Generate_Tree() {
    // Create a group to hold all tree parts
    treeGroup = new THREE.Group();

    // Create the meshes using const (local scope is fine now as they are added to the group)
    const Tree1 = new THREE.Mesh(geometry, Brown);
    const Tree2 = new THREE.Mesh(geometry, Brown);
    const Tree3 = new THREE.Mesh(geometry, Green);
    const Tree4 = new THREE.Mesh(geometry, Green);
    const Tree5 = new THREE.Mesh(geometry, Green);
    const Tree6 = new THREE.Mesh(geometry, Green);
    const Tree7 = new THREE.Mesh(geometry, Green);
    const Tree8 = new THREE.Mesh(geometry, Green);
    const Tree9 = new THREE.Mesh(geometry, Green);
    const Tree10 = new THREE.Mesh(geometry, Green);
    const Tree11 = new THREE.Mesh(geometry, Green);
    const Tree12 = new THREE.Mesh(geometry, Green);
    const Tree13 = new THREE.Mesh(geometry, Green);
    const Tree14 = new THREE.Mesh(geometry, Green);
    const Tree15 = new THREE.Mesh(geometry, Green);
    const Tree16 = new THREE.Mesh(geometry, Green);
    const Tree17 = new THREE.Mesh(geometry, Green);

    // Add the cubes to the group (not directly to the scene)
    treeGroup.add(Tree1);
    treeGroup.add(Tree2);
    treeGroup.add(Tree3);
    treeGroup.add(Tree4);
    treeGroup.add(Tree5);
    treeGroup.add(Tree6);
    treeGroup.add(Tree7);
    treeGroup.add(Tree8);
    treeGroup.add(Tree9);
    treeGroup.add(Tree10);
    treeGroup.add(Tree11);
    treeGroup.add(Tree12);
    treeGroup.add(Tree13);
    treeGroup.add(Tree14);
    treeGroup.add(Tree15);
    treeGroup.add(Tree16);
    treeGroup.add(Tree17);

    // Tree Parts Pos (positions are relative to the group's center)
    Tree2.position.y += 1;
    Tree3.position.y += 2;
    Tree4.position.y += 2;
    Tree4.position.x += 1;
    Tree5.position.y += 2;
    Tree5.position.x -= 1;
    Tree6.position.y += 2;
    Tree6.position.z -= 1;
    Tree6.position.x -= 1;
    Tree7.position.y += 2;
    Tree7.position.z -= 1;
    Tree8.position.y += 2;
    Tree8.position.z -= 1;
    Tree8.position.x += 1;
    Tree9.position.y += 3;
    Tree10.position.y += 2;
    Tree10.position.z += 1;
    Tree11.position.y += 2;
    Tree11.position.z += 1;
    Tree11.position.x -= 1;
    Tree12.position.y += 2;
    Tree12.position.z += 1;
    Tree12.position.x += 1;
    Tree13.position.y += 4;
    Tree14.position.y += 3;
    Tree14.position.z -= 1;
    Tree15.position.y += 3;
    Tree15.position.x += 1;
    Tree16.position.y += 3;
    Tree16.position.x -= 1;
    Tree17.position.y += 3;
    Tree17.position.z += 1;
    
    // Add the entire group to the scene
    scene.add(treeGroup);
}

function Generate_TOP_Chunk() {
    // Create a group to hold all chunk parts
    chunkGroup = new THREE.Group();

    // Create the meshes using const
    const Block1 = new THREE.Mesh(geometry, Green);
    const Block2 = new THREE.Mesh(geometry, Green);
    const Block3 = new THREE.Mesh(geometry, Green);
    const Block4 = new THREE.Mesh(geometry, Green);
    const Block5 = new THREE.Mesh(geometry, Green);
    const Block6 = new THREE.Mesh(geometry, Green);
    const Block7 = new THREE.Mesh(geometry, Green);
    const Block8 = new THREE.Mesh(geometry, Green);
    const Block9 = new THREE.Mesh(geometry, Green);

    // Add the cubes to the group (not directly to the scene)
    chunkGroup.add(Block1);
    chunkGroup.add(Block2);
    chunkGroup.add(Block3);
    chunkGroup.add(Block4);
    chunkGroup.add(Block5);
    chunkGroup.add(Block6);
    chunkGroup.add(Block7);
    chunkGroup.add(Block8);
    chunkGroup.add(Block9);

    // Position Blocks relative to the group center
    Block2.position.z += 1;
    Block3.position.z -= 1;
    Block4.position.x += 1;
    Block5.position.x -= 1;
    Block6.position.z += 1;
    Block6.position.x += 1;
    Block7.position.z += 1;
    Block7.position.x -= 1;
    Block8.position.z -= 1;
    Block8.position.x += 1;
    Block9.position.z -= 1;
    Block9.position.x -= 1;

    // Add the entire group to the scene
    scene.add(chunkGroup);
}

// *** This function now only needs to update the position of the single group ***
function Move_Chunk(X, Y, Z) {
    if (chunkGroup) {
        // Use the Vector3 .add() method for a clean way to update position
        chunkGroup.position.add(new THREE.Vector3(X, Y, Z));
    }
    // Note: If you wanted to move the tree too, you would do the same for treeGroup
}


// === Execution ===
Generate_TOP_Chunk();
Generate_Tree(); 

// This will now successfully move the entire chunkGroup 
// (and all 9 blocks within it) 10 units in X, Y, and Z.
Move_Chunk(0, -1, 0);


// === 4. The Animation Loop ===
function animate() {
    // This creates a loop that causes the renderer to draw the scene every time the screen is refreshed
    requestAnimationFrame(animate);

    // === Camera Animation Logic ===
    // Increment the camera's angle for the next frame
    cameraAngle += 0.005; // Adjust the value to change the rotation speed

    // Update the camera's position on the X and Z axes to make it orbit
    camera.position.x = Math.sin(cameraAngle) * orbitRadius;
    camera.position.z = Math.cos(cameraAngle) * orbitRadius;

    // Point the camera towards the center of the tree (the origin)
    camera.lookAt(0, 0, 0);

    // Render the scene
    renderer.render(scene, camera);
}

// === 5. Handle Window Resize ===
// Ensures the scene looks correct if the browser window is resized
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Start the animation loop
animate();
</script>
